{"version":3,"file":"KeyringController.js","sourceRoot":"","sources":["../src/KeyringController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { TypedTransaction, TxData } from '@ethereumjs/tx';\nimport * as encryptorUtils from '@metamask/browser-passworder';\nimport HDKeyring from '@metamask/eth-hd-keyring';\nimport { normalize as normalizeToHex } from '@metamask/eth-sig-util';\nimport SimpleKeyring from '@metamask/eth-simple-keyring';\nimport { remove0x, isValidJson } from '@metamask/utils';\nimport type {\n  Hex,\n  Json,\n  Bytes,\n  Keyring,\n  KeyringClass,\n  Eip1024EncryptedData,\n} from '@metamask/utils';\n// TODO: Stop using `events`, and remove the notice about this from the README\n// eslint-disable-next-line import/no-nodejs-modules\nimport { EventEmitter } from 'events';\nimport ObservableStore from 'obs-store';\n\nimport { KeyringType, KeyringControllerError } from './constants';\nimport {\n  SerializedKeyring,\n  KeyringControllerArgs,\n  KeyringControllerState,\n} from './types';\n\nconst defaultKeyringBuilders = [\n  keyringBuilderFactory(SimpleKeyring),\n  keyringBuilderFactory(HDKeyring),\n];\n\nclass KeyringController extends EventEmitter {\n  keyringBuilders: { (): Keyring<Json>; type: string }[];\n\n  public store: typeof ObservableStore;\n\n  public memStore: typeof ObservableStore;\n\n  public encryptor: any;\n\n  public keyrings: Keyring<Json>[];\n\n  public cacheEncryptionKey: boolean;\n\n  public unsupportedKeyrings: SerializedKeyring[];\n\n  public password?: string;\n\n  constructor({\n    keyringBuilders,\n    cacheEncryptionKey,\n    initState = {},\n    encryptor = encryptorUtils,\n  }: KeyringControllerArgs) {\n    super();\n    this.keyringBuilders = keyringBuilders\n      ? defaultKeyringBuilders.concat(keyringBuilders)\n      : defaultKeyringBuilders;\n    this.store = new ObservableStore(initState);\n    this.memStore = new ObservableStore({\n      isUnlocked: false,\n      keyringTypes: this.keyringBuilders.map(\n        (keyringBuilder) => keyringBuilder.type,\n      ),\n      keyrings: [],\n      encryptionKey: null,\n    });\n\n    this.encryptor = encryptor;\n    this.keyrings = [];\n    this.unsupportedKeyrings = [];\n\n    // This option allows the controller to cache an exported key\n    // for use in decrypting and encrypting data without password\n    this.cacheEncryptionKey = Boolean(cacheEncryptionKey);\n  }\n\n  /**\n   * Full Update\n   *\n   * Emits the `update` event and @returns a Promise that resolves to\n   * the current state.\n   *\n   * Frequently used to end asynchronous chains in this class,\n   * indicating consumers can often either listen for updates,\n   * or accept a state-resolving promise to consume their results.\n   *\n   * @returns The controller state.\n   */\n  #fullUpdate() {\n    this.emit('update', this.memStore.getState());\n    return this.memStore.getState();\n  }\n\n  /**\n   * =======================================\n   * === Public Vault Management Methods ===\n   * =======================================\n   */\n\n  /**\n   * Create New Vault And Keychain\n   *\n   * Destroys any old encrypted storage,\n   * creates a new encrypted store with the given password,\n   * randomly creates a new HD wallet with 1 account,\n   * faucets that account on the testnet.\n   *\n   * @fires KeyringController#unlock\n   * @param password - The password to encrypt the vault with.\n   * @returns A promise that resolves to the state.\n   */\n  async createNewVaultAndKeychain(\n    password: string,\n  ): Promise<KeyringControllerState> {\n    this.password = password;\n\n    await this.#createFirstKeyTree();\n    this.#setUnlocked();\n    return this.#fullUpdate();\n  }\n\n  /**\n   * CreateNewVaultAndRestore\n   *\n   * Destroys any old encrypted storage,\n   * creates a new encrypted store with the given password,\n   * creates a new HD wallet from the given seed with 1 account.\n   *\n   * @fires KeyringController#unlock\n   * @param password - The password to encrypt the vault with.\n   * @param seedPhrase - The BIP39-compliant seed phrase,\n   * either as a string or Uint8Array.\n   * @returns A promise that resolves to the state.\n   */\n  async createNewVaultAndRestore(\n    password: string,\n    seedPhrase: Uint8Array | string | number[],\n  ): Promise<KeyringControllerState> {\n    if (typeof password !== 'string') {\n      throw new TypeError(KeyringControllerError.WrongPasswordType);\n    }\n    this.password = password;\n\n    await this.#clearKeyrings();\n    const keyring = await this.addNewKeyring(KeyringType.HD, {\n      mnemonic: seedPhrase,\n      numberOfAccounts: 1,\n    });\n\n    const [firstAccount] = await keyring.getAccounts();\n\n    if (!firstAccount) {\n      throw new Error(KeyringControllerError.NoFirstAccount);\n    }\n    this.#setUnlocked();\n    return this.#fullUpdate();\n  }\n\n  /**\n   * Set Locked.\n   * This method deallocates all secrets, and effectively locks MetaMask.\n   *\n   * @fires KeyringController#lock\n   * @returns A promise that resolves to the state.\n   */\n  async setLocked(): Promise<KeyringControllerState> {\n    delete this.password;\n\n    // set locked\n    this.memStore.updateState({\n      isUnlocked: false,\n      encryptionKey: null,\n      encryptionSalt: null,\n    });\n\n    // remove keyrings\n    this.keyrings = [];\n    await this.updateMemStoreKeyrings();\n    this.emit('lock');\n    return this.#fullUpdate();\n  }\n\n  /**\n   * Submit password.\n   *\n   * Attempts to decrypt the current vault and load its keyrings\n   * into memory.\n   *\n   * Temporarily also migrates any old-style vaults first, as well\n   * (Pre MetaMask 3.0.0).\n   *\n   * @fires KeyringController#unlock\n   * @param password - The keyring controller password.\n   * @returns A promise that resolves to the state.\n   */\n  async submitPassword(password: string): Promise<KeyringControllerState> {\n    this.keyrings = await this.unlockKeyrings(password);\n\n    this.#setUnlocked();\n    return this.#fullUpdate();\n  }\n\n  /**\n   * Submit Encryption Key.\n   *\n   * Attempts to decrypt the current vault and load its keyrings\n   * into memory based on the vault and CryptoKey information.\n   *\n   * @fires KeyringController#unlock\n   * @param encryptionKey - The encrypted key information used to decrypt the vault.\n   * @param encryptionSalt - The salt used to generate the last key.\n   * @returns A promise that resolves to the state.\n   */\n  async submitEncryptionKey(\n    encryptionKey: string,\n    encryptionSalt: string,\n  ): Promise<KeyringControllerState> {\n    this.keyrings = await this.unlockKeyrings(\n      undefined,\n      encryptionKey,\n      encryptionSalt,\n    );\n    this.#setUnlocked();\n    return this.#fullUpdate();\n  }\n\n  /**\n   * Verify Password\n   *\n   * Attempts to decrypt the current vault with a given password\n   * to verify its validity.\n   *\n   * @param password - The vault password.\n   */\n  async verifyPassword(password: string): Promise<void> {\n    const encryptedVault = this.store.getState().vault;\n    if (!encryptedVault) {\n      throw new Error(KeyringControllerError.VaultError);\n    }\n    await this.encryptor.decrypt(password, encryptedVault);\n  }\n\n  /**\n   * =========================================\n   * === Public Account Management Methods ===\n   * =========================================\n   */\n\n  /**\n   * Add New Account.\n   *\n   * Calls the `addAccounts` method on the given keyring,\n   * and then saves those changes.\n   *\n   * @param selectedKeyring - The currently selected keyring.\n   * @returns A Promise that resolves to the state.\n   */\n  async addNewAccount(\n    selectedKeyring: Keyring<Json>,\n  ): Promise<KeyringControllerState> {\n    const accounts = await selectedKeyring.addAccounts(1);\n    accounts.forEach((hexAccount) => {\n      this.emit('newAccount', hexAccount);\n    });\n\n    await this.persistAllKeyrings();\n    return this.#fullUpdate();\n  }\n\n  /**\n   * Export Account\n   *\n   * Requests the private key from the keyring controlling\n   * the specified address.\n   *\n   * Returns a Promise that may resolve with the private key string.\n   *\n   * @param address - The address of the account to export.\n   * @returns The private key of the account.\n   */\n  async exportAccount(address: string): Promise<string> {\n    const keyring = await this.getKeyringForAccount(address);\n    if (!keyring.exportAccount) {\n      throw new Error(KeyringControllerError.UnsupportedExportAccount);\n    }\n\n    return await keyring.exportAccount(normalizeToHex(address) as Hex);\n  }\n\n  /**\n   * Remove Account.\n   *\n   * Removes a specific account from a keyring\n   * If the account is the last/only one then it also removes the keyring.\n   *\n   * @param address - The address of the account to remove.\n   * @returns A promise that resolves if the operation was successful.\n   */\n  async removeAccount(address: Hex): Promise<KeyringControllerState> {\n    const keyring = await this.getKeyringForAccount(address);\n\n    // Not all the keyrings support this, so we have to check\n    if (!keyring.removeAccount) {\n      throw new Error(KeyringControllerError.UnsupportedRemoveAccount);\n    }\n    keyring.removeAccount(address);\n    this.emit('removedAccount', address);\n\n    const accounts = await keyring.getAccounts();\n    // Check if this was the last/only account\n    if (accounts.length === 0) {\n      await this.removeEmptyKeyrings();\n    }\n\n    await this.persistAllKeyrings();\n    return this.#fullUpdate();\n  }\n\n  /**\n   * Get Accounts\n   *\n   * Returns the public addresses of all current accounts\n   * managed by all currently unlocked keyrings.\n   *\n   * @returns The array of accounts.\n   */\n  async getAccounts(): Promise<string[]> {\n    const keyrings = this.keyrings || [];\n\n    const keyringArrays = await Promise.all(\n      keyrings.map(async (keyring) => keyring.getAccounts()),\n    );\n    const addresses = keyringArrays.reduce((res, arr) => {\n      return res.concat(arr);\n    }, []);\n\n    return addresses.map(normalizeToHex);\n  }\n\n  /**\n   * Get Keyring Class For Type\n   *\n   * Searches the current `keyringBuilders` array\n   * for a Keyring builder whose unique `type` property\n   * matches the provided `type`,\n   * returning it if it exists.\n   *\n   * @param type - The type whose class to get.\n   * @returns The class, if it exists.\n   */\n  getKeyringBuilderForType(\n    type: string,\n  ): { (): Keyring<Json>; type: string } | undefined {\n    return this.keyringBuilders.find(\n      (keyringBuilder) => keyringBuilder.type === type,\n    );\n  }\n\n  /**\n   * Update memStore Keyrings\n   *\n   * Updates the in-memory keyrings, without persisting.\n   */\n  async updateMemStoreKeyrings(): Promise<Json> {\n    const keyrings = await Promise.all(this.keyrings.map(displayForKeyring));\n    return this.memStore.updateState({ keyrings });\n  }\n\n  /**\n   * ===========================================\n   * === Public RPC Requests Routing Methods ===\n   * ===========================================\n   */\n\n  /**\n   * Sign Ethereum Transaction\n   *\n   * Signs an Ethereum transaction object.\n   *\n   * @param ethTx - The transaction to sign.\n   * @param rawAddress - The transaction 'from' address.\n   * @param opts - Signing options.\n   * @returns The signed transaction object.\n   */\n  async signTransaction(\n    ethTx: TypedTransaction,\n    rawAddress: string,\n    opts: Record<string, unknown> = {},\n  ): Promise<TxData> {\n    const address = normalizeToHex(rawAddress) as Hex;\n    const keyring = await this.getKeyringForAccount(address);\n    if (!keyring.signTransaction) {\n      throw new Error(KeyringControllerError.UnsupportedSignTransaction);\n    }\n\n    return await keyring.signTransaction(address, ethTx, opts);\n  }\n\n  /**\n   * Sign Message\n   *\n   * Attempts to sign the provided message parameters.\n   *\n   * @param msgParams - The message parameters to sign.\n   * @param msgParams.from - From address.\n   * @param msgParams.data - The message to sign.\n   * @param opts - Additional signing options.\n   * @returns The raw signature.\n   */\n  async signMessage(\n    msgParams: {\n      from: string;\n      data: string;\n    },\n    opts: Record<string, unknown> = {},\n  ): Promise<string> {\n    const address = normalizeToHex(msgParams.from) as Hex;\n    const keyring = await this.getKeyringForAccount(address);\n    if (!keyring.signMessage) {\n      throw new Error(KeyringControllerError.UnsupportedSignMessage);\n    }\n\n    return await keyring.signMessage(address, msgParams.data, opts);\n  }\n\n  /**\n   * Sign Personal Message\n   *\n   * Attempts to sign the provided message parameters.\n   * Prefixes the hash before signing per the personal sign expectation.\n   *\n   * @param msgParams - The message parameters to sign.\n   * @param msgParams.from - From address.\n   * @param msgParams.data - The message to sign.\n   * @param opts - Additional signing options.\n   * @returns The raw signature.\n   */\n  async signPersonalMessage(\n    msgParams: {\n      from: string;\n      data: string;\n    },\n    opts: Record<string, unknown> = {},\n  ): Promise<string> {\n    const address = normalizeToHex(msgParams.from) as Hex;\n    const keyring = await this.getKeyringForAccount(address);\n    if (!keyring.signPersonalMessage) {\n      throw new Error(KeyringControllerError.UnsupportedSignPersonalMessage);\n    }\n\n    const normalizedData = normalizeToHex(msgParams.data) as Hex;\n\n    return await keyring.signPersonalMessage(address, normalizedData, opts);\n  }\n\n  /**\n   * Get encryption public key\n   *\n   * Get encryption public key for using in encrypt/decrypt process.\n   *\n   * @param address - The address to get the encryption public key for.\n   * @param opts - Additional encryption options.\n   * @returns The public key.\n   */\n  async getEncryptionPublicKey(\n    address: string,\n    opts: Record<string, unknown> = {},\n  ): Promise<Bytes> {\n    const normalizedAddress = normalizeToHex(address) as Hex;\n    const keyring = await this.getKeyringForAccount(address);\n    if (!keyring.getEncryptionPublicKey) {\n      throw new Error(KeyringControllerError.UnsupportedGetEncryptionPublicKey);\n    }\n\n    return await keyring.getEncryptionPublicKey(normalizedAddress, opts);\n  }\n\n  /**\n   * Decrypt Message\n   *\n   * Attempts to decrypt the provided message parameters.\n   *\n   * @param msgParams - The decryption message parameters.\n   * @param msgParams.from - The address of the account you want to use to decrypt the message.\n   * @param msgParams.data - The encrypted data that you want to decrypt.\n   * @returns The raw decryption result.\n   */\n  async decryptMessage(msgParams: {\n    from: string;\n    data: Eip1024EncryptedData;\n  }): Promise<Bytes> {\n    const address = normalizeToHex(msgParams.from) as Hex;\n    const keyring = await this.getKeyringForAccount(address);\n    if (!keyring.decryptMessage) {\n      throw new Error(KeyringControllerError.UnsupportedDecryptMessage);\n    }\n\n    return keyring.decryptMessage(address, msgParams.data);\n  }\n\n  /**\n   * Sign Typed Data.\n   *\n   * @see {@link https://github.com/ethereum/EIPs/pull/712#issuecomment-329988454|EIP712}.\n   * @param msgParams - The message parameters to sign.\n   * @param msgParams.from - From address.\n   * @param msgParams.data - The data to sign.\n   * @param opts - Additional signing options.\n   * @returns The raw signature.\n   */\n  async signTypedMessage(\n    msgParams: {\n      from: string;\n      data: Record<string, unknown>[];\n    },\n    opts: Record<string, unknown> = { version: 'V1' },\n  ): Promise<Bytes> {\n    const address = normalizeToHex(msgParams.from);\n    const keyring = await this.getKeyringForAccount(address);\n    if (!keyring.signTypedData) {\n      throw new Error(KeyringControllerError.UnsupportedSignTypedMessage);\n    }\n\n    // Looks like this is not well defined in the Keyring interface since\n    // our tests show that we should be able to pass an array.\n    // @ts-expect-error Missing other required permission types.\n    return keyring.signTypedData(address, msgParams.data, opts);\n  }\n\n  /**\n   * Gets the app key address for the given Ethereum address and origin.\n   *\n   * @param rawAddress - The Ethereum address for the app key.\n   * @param origin - The origin for the app key.\n   * @returns The app key address.\n   */\n  async getAppKeyAddress(rawAddress: string, origin: string): Promise<string> {\n    const address = normalizeToHex(rawAddress) as Hex;\n    const keyring = await this.getKeyringForAccount(address);\n    if (!keyring.getAppKeyAddress) {\n      throw new Error(KeyringControllerError.UnsupportedGetAppKeyAddress);\n    }\n\n    return keyring.getAppKeyAddress(address, origin);\n  }\n\n  /**\n   * Exports an app key private key for the given Ethereum address and origin.\n   *\n   * @param rawAddress - The Ethereum address for the app key.\n   * @param origin - The origin for the app key.\n   * @returns The app key private key.\n   */\n  async exportAppKeyForAddress(\n    rawAddress: string,\n    origin: string,\n  ): Promise<string> {\n    const address = normalizeToHex(rawAddress) as Hex;\n    const keyring = await this.getKeyringForAccount(address);\n    if (!keyring.exportAccount) {\n      throw new Error(KeyringControllerError.UnsupportedExportAppKeyForAddress);\n    }\n    return keyring.exportAccount(address, { withAppKeyOrigin: origin });\n  }\n\n  /**\n   * =========================================\n   * === Public Keyring Management Methods ===\n   * =========================================\n   */\n\n  /**\n   * Add New Keyring\n   *\n   * Adds a new Keyring of the given `type` to the vault\n   * and the current decrypted Keyrings array.\n   *\n   * All Keyring classes implement a unique `type` string,\n   * and this is used to retrieve them from the keyringBuilders array.\n   *\n   * @param type - The type of keyring to add.\n   * @param opts - The constructor options for the keyring.\n   * @returns The new keyring.\n   */\n  async addNewKeyring(\n    type: string,\n    opts: Record<string, unknown> = {},\n  ): Promise<Keyring<Json>> {\n    let keyring: Keyring<Json>;\n    switch (type) {\n      case KeyringType.Simple:\n        keyring = await this.#newKeyring(type, opts.privateKeys);\n        break;\n      default:\n        keyring = await this.#newKeyring(type, opts);\n        break;\n    }\n\n    if (!keyring) {\n      throw new Error(KeyringControllerError.NoKeyring);\n    }\n\n    if (!opts.mnemonic && type === KeyringType.HD) {\n      if (!keyring.generateRandomMnemonic) {\n        throw new Error(\n          KeyringControllerError.UnsupportedGenerateRandomMnemonic,\n        );\n      }\n\n      keyring.generateRandomMnemonic();\n      await keyring.addAccounts(1);\n    }\n\n    const accounts = await keyring.getAccounts();\n    await this.checkForDuplicate(type, accounts);\n\n    this.keyrings.push(keyring);\n    await this.persistAllKeyrings();\n\n    this.#fullUpdate();\n\n    return keyring;\n  }\n\n  /**\n   * Remove empty keyrings.\n   *\n   * Loops through the keyrings and removes the ones with empty accounts\n   * (usually after removing the last / only account) from a keyring.\n   */\n  async removeEmptyKeyrings(): Promise<void> {\n    const validKeyrings: Keyring<Json>[] = [];\n\n    // Since getAccounts returns a Promise\n    // We need to wait to hear back form each keyring\n    // in order to decide which ones are now valid (accounts.length > 0)\n\n    await Promise.all(\n      this.keyrings.map(async (keyring: Keyring<Json>) => {\n        const accounts = await keyring.getAccounts();\n        if (accounts.length > 0) {\n          validKeyrings.push(keyring);\n        }\n      }),\n    );\n    this.keyrings = validKeyrings;\n  }\n\n  /**\n   * Checks for duplicate keypairs, using the the first account in the given\n   * array. Rejects if a duplicate is found.\n   *\n   * Only supports 'Simple Key Pair'.\n   *\n   * @param type - The key pair type to check for.\n   * @param newAccountArray - Array of new accounts.\n   * @returns The account, if no duplicate is found.\n   */\n  async checkForDuplicate(\n    type: string,\n    newAccountArray: string[],\n  ): Promise<string[]> {\n    const accounts = await this.getAccounts();\n\n    switch (type) {\n      case KeyringType.Simple: {\n        const isIncluded = Boolean(\n          accounts.find(\n            (key) =>\n              newAccountArray[0] &&\n              (key === newAccountArray[0] ||\n                key === remove0x(newAccountArray[0])),\n          ),\n        );\n\n        if (isIncluded) {\n          throw new Error(KeyringControllerError.DuplicatedAccount);\n        }\n        return newAccountArray;\n      }\n\n      default: {\n        return newAccountArray;\n      }\n    }\n  }\n\n  /**\n   * Get Keyring For Account\n   *\n   * Returns the currently initialized keyring that manages\n   * the specified `address` if one exists.\n   *\n   * @param address - An account address.\n   * @returns The keyring of the account, if it exists.\n   */\n  async getKeyringForAccount(address: string): Promise<Keyring<Json>> {\n    const hexed = normalizeToHex(address);\n\n    const candidates = await Promise.all(\n      this.keyrings.map(async (keyring) => {\n        return Promise.all([keyring, keyring.getAccounts()]);\n      }),\n    );\n\n    const winners = candidates.filter((candidate) => {\n      const accounts = candidate[1].map(normalizeToHex);\n      return accounts.includes(hexed);\n    });\n\n    if (winners.length && winners[0]?.length) {\n      return winners[0][0];\n    }\n\n    // Adding more info to the error\n    let errorInfo = '';\n    if (!address) {\n      errorInfo = 'The address passed in is invalid/empty';\n    } else if (!candidates.length) {\n      errorInfo = 'There are no keyrings';\n    } else if (!winners.length) {\n      errorInfo = 'There are keyrings, but none match the address';\n    }\n    throw new Error(\n      `${KeyringControllerError.NoKeyring}. Error info: ${errorInfo}`,\n    );\n  }\n\n  /**\n   * Restore Keyring\n   *\n   * Attempts to initialize a new keyring from the provided serialized payload.\n   * On success, updates the memStore keyrings and returns the resulting\n   * keyring instance.\n   *\n   * @param serialized - The serialized keyring.\n   * @returns The deserialized keyring.\n   */\n  async restoreKeyring(\n    serialized: SerializedKeyring,\n  ): Promise<Keyring<Json> | undefined> {\n    const keyring = await this.#restoreKeyring(serialized);\n    if (keyring) {\n      await this.updateMemStoreKeyrings();\n    }\n    return keyring;\n  }\n\n  /**\n   * Get Keyrings by Type\n   *\n   * Gets all keyrings of the given type.\n   *\n   * @param type - The keyring types to retrieve.\n   * @returns Keyrings matching the specified type.\n   */\n  getKeyringsByType(type: string): Keyring<Json>[] {\n    const keyrings = this.keyrings.filter((keyring) => keyring.type === type);\n    if (!keyrings.length) {\n      throw new Error(KeyringControllerError.NoKeyring);\n    }\n    return keyrings;\n  }\n\n  /**\n   * Persist All Keyrings\n   *\n   * Iterates the current `keyrings` array,\n   * serializes each one into a serialized array,\n   * encrypts that array with the provided `password`,\n   * and persists that encrypted string to storage.\n   *\n   * @returns Resolves to true once keyrings are persisted.\n   */\n  async persistAllKeyrings(): Promise<boolean> {\n    const { encryptionKey, encryptionSalt } = this.memStore.getState();\n\n    if (!this.password && !encryptionKey) {\n      throw new Error(KeyringControllerError.MissingCredentials);\n    }\n\n    const serializedKeyrings = await Promise.all(\n      this.keyrings.map(async (keyring) => {\n        const [type, data] = await Promise.all([\n          keyring.type,\n          keyring.serialize(),\n        ]);\n        return { type, data };\n      }),\n    );\n\n    serializedKeyrings.push(...this.unsupportedKeyrings);\n\n    let vault;\n    let newEncryptionKey;\n\n    if (this.cacheEncryptionKey) {\n      if (this.password) {\n        const { vault: newVault, exportedKeyString } =\n          await this.encryptor.encryptWithDetail(\n            this.password,\n            serializedKeyrings,\n          );\n\n        vault = newVault;\n        newEncryptionKey = exportedKeyString;\n      } else if (encryptionKey) {\n        const key = await this.encryptor.importKey(encryptionKey);\n        const vaultJSON = await this.encryptor.encryptWithKey(\n          key,\n          serializedKeyrings,\n        );\n        vaultJSON.salt = encryptionSalt;\n        vault = JSON.stringify(vaultJSON);\n      }\n    } else {\n      if (typeof this.password !== 'string') {\n        throw new TypeError(KeyringControllerError.WrongPasswordType);\n      }\n      vault = await this.encryptor.encrypt(this.password, serializedKeyrings);\n    }\n\n    if (!vault) {\n      throw new Error(KeyringControllerError.MissingVaultData);\n    }\n\n    this.store.updateState({ vault });\n\n    // The keyring updates need to be announced before updating the encryptionKey\n    // so that the updated keyring gets propagated to the extension first.\n    // Not calling {@link updateMemStoreKeyrings} results in the wrong account being selected\n    // in the extension.\n    await this.updateMemStoreKeyrings();\n    if (newEncryptionKey) {\n      this.memStore.updateState({\n        encryptionKey: newEncryptionKey,\n        encryptionSalt: JSON.parse(vault).salt,\n      });\n    }\n\n    return true;\n  }\n\n  /**\n   * Unlock Keyrings.\n   *\n   * Attempts to unlock the persisted encrypted storage,\n   * initializing the persisted keyrings to RAM.\n   *\n   * @param password - The keyring controller password.\n   * @param encryptionKey - An exported key string to unlock keyrings with.\n   * @param encryptionSalt - The salt used to encrypt the vault.\n   * @returns The keyrings array.\n   */\n  async unlockKeyrings(\n    password: string | undefined,\n    encryptionKey?: string,\n    encryptionSalt?: string,\n  ): Promise<Keyring<Json>[]> {\n    const encryptedVault = this.store.getState().vault;\n    if (!encryptedVault) {\n      throw new Error(KeyringControllerError.VaultError);\n    }\n\n    await this.#clearKeyrings();\n\n    let vault;\n\n    if (this.cacheEncryptionKey) {\n      if (password) {\n        const result = await this.encryptor.decryptWithDetail(\n          password,\n          encryptedVault,\n        );\n        vault = result.vault;\n        this.password = password;\n\n        this.memStore.updateState({\n          encryptionKey: result.exportedKeyString,\n          encryptionSalt: result.salt,\n        });\n      } else {\n        const parsedEncryptedVault = JSON.parse(encryptedVault);\n\n        if (encryptionSalt !== parsedEncryptedVault.salt) {\n          throw new Error(KeyringControllerError.ExpiredCredentials);\n        }\n\n        if (typeof encryptionKey !== 'string') {\n          throw new TypeError(KeyringControllerError.WrongPasswordType);\n        }\n\n        const key = await this.encryptor.importKey(encryptionKey);\n        vault = await this.encryptor.decryptWithKey(key, parsedEncryptedVault);\n\n        // This call is required on the first call because encryptionKey\n        // is not yet inside the memStore\n        this.memStore.updateState({\n          encryptionKey,\n          encryptionSalt,\n        });\n      }\n    } else {\n      if (typeof password !== 'string') {\n        throw new TypeError(KeyringControllerError.WrongPasswordType);\n      }\n\n      vault = await this.encryptor.decrypt(password, encryptedVault);\n      this.password = password;\n    }\n\n    await Promise.all(vault.map(this.#restoreKeyring.bind(this)));\n    await this.updateMemStoreKeyrings();\n    return this.keyrings;\n  }\n\n  // =======================\n  // === Private Methods ===\n  // =======================\n\n  /**\n   * Create First Key Tree.\n   *\n   * - Clears the existing vault.\n   * - Creates a new vault.\n   * - Creates a random new HD Keyring with 1 account.\n   * - Makes that account the selected account.\n   * - Faucets that account on testnet.\n   * - Puts the current seed words into the state tree.\n   *\n   * @returns A promise that resolves if the operation was successful.\n   */\n  async #createFirstKeyTree(): Promise<null> {\n    await this.#clearKeyrings();\n\n    const keyring = await this.addNewKeyring(KeyringType.HD);\n    if (!keyring) {\n      throw new Error(KeyringControllerError.NoKeyring);\n    }\n\n    const [firstAccount] = await keyring.getAccounts();\n    if (!firstAccount) {\n      throw new Error(KeyringControllerError.NoAccountOnKeychain);\n    }\n\n    const hexAccount = normalizeToHex(firstAccount);\n    this.emit('newVault', hexAccount);\n    return null;\n  }\n\n  /**\n   * Restore Keyring Helper\n   *\n   * Attempts to initialize a new keyring from the provided serialized payload.\n   * On success, returns the resulting keyring instance.\n   *\n   * @param serialized - The serialized keyring.\n   * @param serialized.type - Keyring type.\n   * @param serialized.data - Keyring data.\n   * @returns The deserialized keyring or undefined if the keyring type is unsupported.\n   */\n  async #restoreKeyring(\n    serialized: SerializedKeyring,\n  ): Promise<Keyring<Json> | undefined> {\n    const { type, data } = serialized;\n\n    let keyring: Keyring<Json> | undefined;\n    try {\n      keyring = await this.#newKeyring(type, data);\n    } catch (error) {\n      // Ignore error.\n      console.error(error);\n    }\n\n    if (!keyring) {\n      this.unsupportedKeyrings.push(serialized);\n      return undefined;\n    }\n\n    // getAccounts also validates the accounts for some keyrings\n    await keyring.getAccounts();\n    this.keyrings.push(keyring);\n    return keyring;\n  }\n\n  /**\n   * Clear Keyrings\n   *\n   * Deallocates all currently managed keyrings and accounts.\n   * Used before initializing a new vault.\n   */\n  async #clearKeyrings(): Promise<void> {\n    // clear keyrings from memory\n    this.keyrings = [];\n    this.memStore.updateState({\n      keyrings: [],\n    });\n  }\n\n  /**\n   * Unlock Keyrings\n   *\n   * Unlocks the keyrings.\n   *\n   * @fires KeyringController#unlock\n   */\n  #setUnlocked(): void {\n    this.memStore.updateState({ isUnlocked: true });\n    this.emit('unlock');\n  }\n\n  /**\n   * Instantiate, initialize and return a new keyring\n   *\n   * The keyring instantiated is of the given `type`.\n   *\n   * @param type - The type of keyring to add.\n   * @param data - The data to restore a previously serialized keyring.\n   * @returns The new keyring.\n   */\n  async #newKeyring(type: string, data: unknown): Promise<Keyring<Json>> {\n    const keyringBuilder = this.getKeyringBuilderForType(type);\n\n    if (!keyringBuilder) {\n      throw new Error(\n        `${KeyringControllerError.NoKeyringBuilder}. Keyring type: ${type}`,\n      );\n    }\n\n    const keyring = keyringBuilder();\n\n    if (!isValidJson(data)) {\n      throw new Error(KeyringControllerError.DataType);\n    }\n\n    await keyring.deserialize(data);\n\n    // @ts-expect-error The method 'init' is not part of the current Keyring type\n    if (keyring.init) {\n      // @ts-expect-error The method 'init' is not part of the current Keyring type\n      await keyring.init();\n    }\n\n    return keyring;\n  }\n}\n\n/**\n * Get builder function for `Keyring`\n *\n * Returns a builder function for `Keyring` with a `type` property.\n *\n * @param KeyringConstructor - The Keyring class for the builder.\n * @returns A builder function for the given Keyring.\n */\nfunction keyringBuilderFactory(KeyringConstructor: KeyringClass<Json>) {\n  const builder = () => new KeyringConstructor();\n\n  builder.type = KeyringConstructor.type;\n\n  return builder;\n}\n\n/**\n * Display For Keyring\n *\n * Is used for adding the current keyrings to the state object.\n *\n * @param keyring - The keyring to display.\n * @returns A keyring display object, with type and accounts properties.\n */\nasync function displayForKeyring(\n  keyring: Keyring<Json>,\n): Promise<{ type: string; accounts: string[] }> {\n  const accounts = await keyring.getAccounts();\n\n  return {\n    type: keyring.type,\n    accounts: accounts.map(normalizeToHex),\n  };\n}\n\nexport { KeyringController, keyringBuilderFactory };\n"]}